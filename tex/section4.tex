\subsection{Архитектура на софтуерната програма}
Софтуерната програма е съставена от 4 модула, които комуникират помежду си.

\begin{figure}[here]
\includegraphics{modules}
\caption{Архитектура на софтуерната програма}
\label{fig:architecture}
\end{figure}

\begin{itemize}
    \item Feed  модул, който има за отговорност да захранва с данни останалите модули с граф, който за всяка точка съдържа разстояниято между точката и всички останали точки. Ако разстоянието между две точки не може да бъде измерено то тогава разстоянието се означава с специален флаг поле, което е дефинирано като -безкрайност.
    \item Graph Parser модул, който има за цел да обработи информацията, която ‘Feed’ модулът изпраща и да я трансформира в друг граф – който държи информацията във върхове и дъги. Върховете и 
    дъгите съдържат информация, която помага за визуализацията на графа в 3D.
    \item Graph Coordinator модул, който има за цел да определи -координатите в пространството на всички обекти, които се съдържат в графа, който се получава в резултат на стъпка 2 (Graph Parser). Координатите се определят чрез система от линейни уравнения, които считат, че началната позиция на стационарните обекти е (0,0,0) - в един от ъглите на мястото, в което щже бъдат следени обектите.
    \item Graph Visualizer модул, който има за цел да използва графа, чиито координати са били вече определени от Graph Coordinator и да ги визуализира по удачен начин в 3 измерения.
\end{itemize}

\pagebreak

\subsection{Feed модул}
Feed модулът има за цел да създаде граф, който съдържа дистанциите от всяка точка до всяка друга. Нуждата от възможност за лесна и бърза смяна между двата подхода наложи създаването на модула.\\
В процеса на работа бяха изградени 2 различни начина за получаване на данните от ултразвук предаватели към ултразвук получатели. 
\begin{enumerate}
    \itemДанните се получават директно от физическите обекти. Стандартното измерване се случва чрез получаване на данните през сериен порт. Данните се предоставят от ултразвукови предаватели и получатели в специален формат, който бива преобразуван към граф, съдържащ разстоянията между различните точки.
    \itemДанните биват генерирани чрез компютърен модел. Компютърния модел се състои от генератор на дистанции, който симулира движението на реален обект. Това се постига чрез манипулация на дистанцията между двойка (движещ,недвижещ) обект в пространството с константна стойност на определен интервал. Добавен е елемент на случайност, който позволява да се придаде по-реалистичен вид на движението на обектите.
\end{enumerate}

\pagebreak

\subsection{Graph Parser модул}
Graph Parser модулът има за цел да използва графа генериран от Feed модулът, за да създаде граф на свързаност, който съдържа
\begin{enumerate}
\itemВърхове, които представляват движещи/недвижещи се обекти 
\itemДъги, свързващи върховете, които означават съществуването на свързаност между
даден връх и друг връх.
\end{enumerate}

\pagebreak

\subsection{Graph Coordinator модул}
Целта на Graph Coordinator модула е да определи координатите в 3D на построения граф. Тази операция се извършва чрез минимизиране на бройката на възможните позиции използвайки система от уравнения. Всички възможни позиции се намират на радиус с дължина R (равен на дистанцията получена от сензора) на сфера. Задачата се трансформира:\\

\textit{За всеки получател се образуват K сфери (K=броя на трансмитерите), като сфера $x_i$ се центрира в позицията на на трансмитер с индекс $i$, а радиусът и е равен на измерената стойност за разстоянието между двата обекта. За да получим еднозначно решение ние трябва да елиминираме всички възможни позиции освен една. Всички решения на задачата за даден получател се намират на пресечния регион на всички сфери за дадения получател. Търси се такава конфигурация на позициите на всички получатели така че назначените позиции да не са в конфликт и броят на възможни решения за всяка позиция да е минимален.}\\\\

В 2D намирането на решения е лесно, поради следните причини:

\begin{enumerate}
    \itemБроят на пресечните точки на сферите при оптимално* позициониране на сензорите лесно може да бъде сведено до еднозначно решение.

    \itemВ 2-D пресечните точки на окръжностите са точки. В 3D пресечните точки са множество от точки. Това лесно може да бъде видяно на фигура \ref{spheres}.
\end{enumerate}

\begin{figure}
    \centerline{\includegraphics{spheres}}
    \caption{Пресечната точка на сфери в 3D е набор от точки}
    \label{spheres}
\end{figure}

Изследвани са няколко начина за намиране на валидни решения на проблема. Изпозлвайки метода на най-малките квадрати представен в \cite{leastsq} се демонстрира намиране на решение чрез разширение на Теоремата на Питагор за 3D. За да се трансформира горната задача в математически модел е нужно да имаме anchor\cite{leastsq2}, което преставлява ориентировъчна точка в пространстовото, в което ще определяме координатитите. За anchor обект избираме позицията на първия трансмитер във виртуалното пространство. Позицията във виртуалното пространството на трансмитерите е константно и е известно винаги.

\begin{equation} \label{pytEq}
   (x-x_i)^2 + (y-y_i)^2 + (z-z_i)^2=d_i^2
\end{equation}



Уравнение \ref{pytEq} описва взаимовръзката между разстоянието и координатите на два обекта. За да генерализираме уравнението с индекс \textit{l} означаваме стойностите за anchor обекта. Чрез трансформация на уравнението се достига до следния запис:

\begin{equation} \label{pytEqTransformed}
  2 x (x_i - x_l) - 2 y (y_i - y_l) - 2  z  (z_i - z_l) = d^2_i - d^2_l - k_l + k_i
\end{equation}

За краткост в уравнение \ref{pytEqTransformed} променливата \textit{k} е означена като: 
\begin{equation} \label{kdesc}
    k_i= x^2_i + y^2_i + z^2_i
\end{equation}

Използваме това уравнение за всички получатели, което за брой на получателите = 3 е следното матрично уравнение:

\centerline \\
    2 {\begin{bmatrix}
        (x_2-x_1) & (y_2 - y_1) & (z_2 - z_1)\\
        (x_3-x_1) & (y_3 - y_1) & (z_3 - z_1)\\
        (x_4-x_1) & (y_4 - y_1) & (z_4 - z_1)
    \end{bmatrix}
    \begin{bmatrix}
        x\\y\\z
    \end{bmatrix}
    =
    \begin{bmatrix}
    d^2_1 - d^2_2 - k_1 + k_2\\
    d^2_1 - d^2_3 - k_1 + k_3\\
    d^2_1 - d^2_4 - k_1 + k_4\\
    \end{bmatrix}\\
}
